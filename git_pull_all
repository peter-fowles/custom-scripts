#!/bin/bash

# ==============================================================================
# git_pull_all - A script to manage git pull operations across multiple
# repositories.
#
# Features:
#   - Pulls latest changes for all Git repositories under a specified root.
#   - List mode (-l) to preview all repositories and their pull status.
#   - Verbose list mode (-lv) to also show changed files after a fetch.
#   - Robust error handling for invalid arguments and non-Git directories.
#   - Color-coded output for improved readability.
#
# Usage:
#   gpa [<directory>] [-i <dir1,dir2,...>] [-l [-v]] [-h]
#
# Examples:
#   # Pull all repos in the current directory
#   gpa
#
#   # Pull all repos in a specific directory
#   gpa ~/projects
#
#   # List all repos and their pull status, ignoring the 'temp' directory
#   gpa -l -i "temp"
#
#   # Verbose list, showing files changed after a dry run pull
#   gpa -lv
#
# ==============================================================================

# Fix for "fatal: not a git repository" errors across filesystems.
export GIT_DISCOVERY_ACROSS_FILESYSTEM=1

# --- Configuration ---

# Define the default directories to ignore
default_ignored_dirs=("node_modules" "vendor" "build" ".venv")

# Define ANSI color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# --- Argument Parsing ---

user_ignored_dirs=""
is_list_mode=false
is_verbose_list=false
root_directory="$(pwd)"

usage() {
  echo -e "${BOLD}Usage:${NC} $0 [<directory>] [-i <dir1,dir2,...>] [-l [-v]] [-h]"
  echo ""
  echo -e "${BOLD}Arguments:${NC}"
  echo "  <directory>               Optional. The root directory to start searching for Git repos."
  echo "                            Defaults to the current working directory."
  echo ""
  echo -e "${BOLD}Options:${NC}"
  echo "  -i <dir1,dir2,...>        Optional. Append additional directories to the ignore list."
  echo "                            Provide a comma-separated string with no spaces."
  echo "  -l                        List all repositories and their pull status."
  echo "  -v                        Used with -l to give verbose output (show files changed after fetch)."
  echo "  -h                        Display this help message and exit."
  exit 1
}

# Parse command-line arguments and validate
while [[ "$#" -gt 0 ]]; do
  case "$1" in
    -i)
      if [[ -z "$2" || "$2" == -* ]]; then
        echo -e "${RED}Error:${NC} '-i' requires a list of directories." >&2
        usage
      fi
      user_ignored_dirs="$2"
      shift
      ;;
    -l)
      is_list_mode=true
      ;;
    -v)
      is_verbose_list=true
      ;;
    -h)
      usage
      ;;
    -*)
      echo -e "${RED}Invalid option:${NC} $1" >&2
      usage
      ;;
    *)
      if [[ "$root_directory" != "$(pwd)" ]]; then
        echo -e "${RED}Error:${NC} Cannot specify multiple directories. Already set to '${BOLD}$root_directory${NC}'." >&2
        usage
      fi
      root_directory="$1"
      ;;
  esac
  shift
done

# Perform post-parsing validation
if [[ "$is_verbose_list" = true && "$is_list_mode" = false ]]; then
  echo -e "${RED}Error:${NC} The '-v' flag can only be used in conjunction with '-l'." >&2
  usage
fi

all_ignored_dirs=("${default_ignored_dirs[@]}")
if [[ -n "$user_ignored_dirs" ]]; then
  IFS=',' read -ra user_dirs_array <<< "$user_ignored_dirs"
  all_ignored_dirs+=("${user_dirs_array[@]}")
fi

declare -A unique_dirs
for dir in "${all_ignored_dirs[@]}"; do
  unique_dirs["$dir"]=1
done
final_ignored_dirs=("${!unique_dirs[@]}")

# --- Core Script Logic ---

if [[ ! -d "$root_directory" ]]; then
  echo -e "${RED}Error:${NC} The specified directory '${BOLD}$root_directory${NC}' does not exist." >&2
  exit 1
fi

ignore_expression=""
for dir in "${final_ignored_dirs[@]}"; do
  ignore_expression+="-path */$dir -prune -o "
done

process_repos() {
  find "$root_directory" -type d \( $ignore_expression -false \) -o -name ".git" | while read git_dir; do
    repo_dir=$(dirname "$git_dir")
    
    if ! git -C "$repo_dir" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
      continue
    fi
    
    # Check if there are updates to pull
    git -C "$repo_dir" fetch --quiet 2>/dev/null
    local_behind_remote=false
    if [[ -n $(git -C "$repo_dir" log HEAD..@{u} --oneline 2>/dev/null) ]]; then
        local_behind_remote=true
    fi

    if [[ "$is_list_mode" = true ]]; then
      if [[ "$local_behind_remote" = true ]]; then
        echo -e "${YELLOW}Updates available in:${NC} ${BOLD}$repo_dir${NC}"
      else
        echo -e "No updates available in: ${BOLD}$repo_dir${NC}"
      fi
      
      if [[ "$is_verbose_list" = true && "$local_behind_remote" = true ]]; then
        local changed_files=$(git -C "$repo_dir" diff --name-status HEAD..@{u})
        echo "$changed_files" | awk '{print "  "$0}'
      fi
    else # Default mode: Pull updates
      if [[ "$local_behind_remote" = true ]]; then
        echo -e "${BOLD}--- Pulling updates in:${NC} ${CYAN}$repo_dir${NC}"
        if git -C "$repo_dir" pull; then
          echo -e "${GREEN}--- Successfully pulled updates in ${BOLD}$repo_dir${NC}."
        else
          echo -e "${RED}--- Failed to pull updates in ${BOLD}$repo_dir${NC}. Please check manually."
        fi
        echo -e "--- Finished with repository: ${CYAN}$repo_dir${NC}"
        echo ""
      else
        echo -e "No updates available in: ${BOLD}$repo_dir${NC}"
      fi
    fi
  done
}

if [[ "$is_list_mode" = true ]]; then
  echo -e "${BOLD}Listing all Git repositories in '${CYAN}$root_directory${NC}':"
  process_repos
else
  echo -e "${BOLD}Starting automated Git pull...${NC}"
  echo -e "Root directory: ${CYAN}$root_directory${NC}"
  echo -e "Ignoring directories: ${YELLOW}${final_ignored_dirs[*]}${NC}"
  echo ""
  process_repos
  echo -e "${GREEN}Script completed.${NC}"
fi
